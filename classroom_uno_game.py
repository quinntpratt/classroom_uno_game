#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue May 21 19:47:44 2024

@author: Quinn Pratt, Riley Pratt

"""
import numpy as np
import random
import matplotlib.pyplot as plt

class UnoGame(object):
    def __init__(self, name, verbose=False,init_points=50):
        """
        Initialization of the UnoGame class.

        Parameters
        ----------
        name : str
            Name used as a label for this class instance.
        verbose : bool, optional
            Print information useful for debugging. The default is False.
        init_points : int, optional
            Initial points for the game. The default is 50.

        """
        self.name = name
        self.round = 0
        self.n_drawn_this_round = 0
        self.max_round = 100
        self.game_over = False
        
        # Start with a randomly shuffled full deck (list),
        self.deck = self.get_full_deck()
        
        # Dictionary of messages to print per card, 
        self.verbose = verbose
        self.message = {-5:"draw-4",-4:"wild",-3:"draw-2",-2:"reverse",-1:"skip"}
        self.message.update(dict(zip(range(10),[f"{i} card" for i in range(10)])))
        
        # Preallocate output,
        self.points = [init_points]
        self.points_per_round = [init_points]
        self.history = []
        self.n_drawn_total = 0
    
    def get_full_deck(self):
        """
        UnoGame class method to obtain a full, shuffled deck of UNO cards.
        Standard UNO deck contains,
            8 ones-nines: 1-9
            4 zeros: 0
            8 skip :-1
            8 reverse :-2
            8 draw-2 :-3
            4 wild : -4
            4 draw-4 :-5

        Returns
        -------
        deck : list
            Shuffled deck of UNO cards represented by integers.

        """
        a4 = np.array([-5, -4, 0]) # Cards with cardinality 4
        a8 = np.concatenate( (np.array([-3, -2, -1]), np.arange(1,10,1) ) ) # Cards with cardinality 8
        deck = list(np.concatenate( (np.repeat(a4,4),np.repeat(a8,8)) )) # full deck.
        random.shuffle(deck)
        return deck
        
    def draw(self, N):
        """
        UnoGame class method to draw N cards from the shuffled UNO deck.

        Parameters
        ----------
        N : int
            Number of cards to draw.

        Returns
        -------
        list
            List containing N draws from deck.

        """
        return [self.deck.pop(0) for i in range(N)]
    
    def score(self, cards, prefix=""):
        """
        UnoGame class method to score N cards from a drawing.

        Parameters
        ----------
        cards : list
            List of cards generated by the self.draw method.
        prefix : str, optional
            Prefix to append to printed messages (if self.verbose).
            Helps identify recursive calls. The default is "".

        """
        for c in cards:
            if self.verbose:
                print(prefix + self.message[c])
            if c >= 0:
                self.points += [self.points[-1] - c]
            elif c == -1:
                # skip
                self.points += [self.points[-1]]
            elif c == -2:
                # reverse = draw card, if numeric add to other team.
                # draw another card --> gets added to another team but only if 0-9
                new = self.draw(1)[0]
                if self.verbose:
                    print(prefix + "\t" + self.message[new])
                if new >= 0:
                    self.points_to_distr += new
                self.n_drawn_this_round += 1
            elif c == -3:
                # draw 2
                new = self.draw(2)
                self.score(new, prefix=prefix+"\t")
            elif c == -4:
                # wild = pick another card.
                new = self.draw(1)
                self.score(new, prefix=prefix+"\t")
            elif c == -5:
                new = self.draw(4)
                self.score(new, prefix=prefix+"\t")
        
        # add cards to history of cards, 
        self.history += list(cards)
        # helps with recursion, 
        self.n_drawn_this_round += len(cards)        

    def check_game_over(self):
        """
        UnoGame class method to check if the game has ended.
        Updates the self.game_over boolean attribute.

        """
        # Check if the game has ended,
        if self.round >= self.max_round:
            message = "Number of draws has reached max-draws."
            self.game_over = True
        if self.points[-1] <= 1:
            message = "Score has dropped below zero!"
            self.game_over = True
        
        if self.verbose: 
            if self.game_over:
                print(message)
            else:
                print(f"{self.name} - Round {self.round} ended with, ")
                print(f"\t * cards drawn this round: {self.n_drawn_this_round}")
                print(f"\t * points = {self.points[-1]}")
                print(f"\t * points to distribute = {self.points_to_distr}")
    
    def play(self,N=1):        
        """
        UnoGame class method to play one round of the classroom UNO game.

        Parameters
        ----------
        N : int, optional
            Number of cards initially drawn per round. The default is 1.

        """
        # Check if game has ended - if not increment round and draw counter.
        if self.game_over:
            return
        else:
            self.round += 1
            self.n_drawn_total += self.n_drawn_this_round
        # Reset for each round,
        self.n_drawn_this_round = 0
        self.points_to_distr = 0
        self.deck = self.get_full_deck()
        
        # Main drawn,
        cards = self.draw(N)
        self.score(cards)
        
        # Also track the ending points each round.
        self.points_per_round += [self.points[-1]]
        # Check if the game ended.
        self.check_game_over()


def group_play(*args, verbose=False, uno_kwargs=None):
    """
    Function to play the classroom UNO game with a group of players.
    Example,
        players = group_play("Class 1", "Class 2")

    Parameters
    ----------
    *args : str
        names for the players.
    verbose : bool, optional
        Option to print information for debugging. The default is False.
    uno_kwargs : dict, optional
        Extra kwargs passed to UnoGame class instances. The default is None.

    Returns
    -------
    players : list
        List of UnoGame instances corresponding to the players.

    """
    N_players = len(args)
    if N_players <= 1:
        print("Number of players must be > 1")
        return
    if uno_kwargs is None:
        uno_kwargs = dict()
    names = args
    # Make instances,
    players = [UnoGame(name, **uno_kwargs) for name in names]
    # Track everyone's points,
    players_points = [p.points[-1] for p in players]
    proceed = True
    n = 0
    while proceed:
        if verbose:
            print(f"Group Play: Round {n}")
        for i, player in enumerate(players):
            if player.game_over:
                continue
            if verbose:
                print(f"{player.name}'s turn:")
                print(f"\tstart with {player.points[-1]} points.")
            # play one round,
            player.play()
            # if they have adversarial points from a "reverse" card...
            if player.points_to_distr > 0:
                other_players = [j for j in range(N_players) if j != i]
                # General behavior is to target player with the lowest score,
                winner_ind = np.argmin([ players_points[j] for j in other_players ])
                target = other_players[winner_ind]
                # update their points,
                players[target].points[-1] += player.points_to_distr
                if verbose:
                    print(f"\tgive {player.points_to_distr} point(s) to {players[target].name}!")
            # Update the record of their points,
            players_points[i] = player.points[-1]
            if verbose:
                print(f"\tend with {player.points[-1]} points.")
        # Outside the player loop - check if any players remain,
        if all([p.game_over for p in players]):
            if verbose:
                print("No more players!")
            proceed = False
        n += 1

    return players
        

# %% Single-round,
game = UnoGame("test", verbose=True)
game.play()
print("-"*32)

# %% Peaceful gameplay,
game = UnoGame("test", verbose=True)
while not game.game_over:
    game.play()
print("Peaceful gameplay has ended with:")
print(game.points_per_round)
print(game.round)
print("-"*32)

# %% Monte-carlo analysis of peaceful gameplay,
N_games = 500
rounds = np.zeros(N_games)
cards_drawn = np.zeros(N_games)
for i in range(N_games):
    game = UnoGame("MC")
    while not game.game_over:
        game.play()
    rounds[i] = game.round
    cards_drawn[i] = game.n_drawn_total

print(f"Peaceful average rounds: {np.average(rounds):.3f}")

fig, (axr, axc) = plt.subplots(1,2,num="UnoGame: MonteCarlo Analysis")
axr.hist(rounds, ec="k",color="b",alpha=0.3,label=f"Peaceful (N={N_games})")
axr.set_xlabel("Rounds Played")
axc.hist(cards_drawn, ec="k",color="b",alpha=0.3,label=f"Peaceful (N={N_games})")
axc.set_xlabel("Cards Drawn")

# %% Adversarial gameplay,

names = ["Period A", "Period B", "Period C", "Homeroom"]
players = group_play(*names,verbose=True)

fig, ax = plt.subplots(1,1, num="UnoGame: Adversarial Gameplay")
for p in players:
    ax.plot(p.points_per_round, '-o', label=f"{p.name}")

ax.axhline(0,color="k",ls="--")
ax.set_xlabel("Rounds")
ax.set_ylabel("Points")
plt.legend()    

# %% Monte-carlo analysis of adversarial gameplay,

N_games = 100
N_players = 5
names = [f"Player {i}" for i in range(N_players)]
rounds = np.zeros((N_games,N_players))
cards_drawn = np.zeros((N_games,N_players))
for i in range(N_games):
    players = group_play(*names)
    rounds[i,:] = np.array([p.round for p in players])
    cards_drawn[i,:] = np.array([p.n_drawn_total for p in players])

print(f"Adversarial average rounds: {np.average(rounds.flatten()):.3f}")


axr.hist(rounds.flatten(), ec="k",color="r",alpha=0.3,label=f"Adversarial (N={N_games},{N_players} players)")
axc.hist(cards_drawn.flatten(), ec="k",color="r",alpha=0.3,label=f"Adversarial (N={N_games},{N_players} players)")

axr.legend()
axc.legend()
